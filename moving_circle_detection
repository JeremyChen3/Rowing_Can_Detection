import cv2 as cv
import numpy as np

# --- tiny tracking state ---
prev_circle = None
frame_id = 0
misses = 0

ALPHA = 0.30
DETECT_EVERY = 3
MAX_MISSES = 10
SCALE = 0.40  # smaller = faster


def smooth_circle(new_c, old_c):
    if old_c is None:
        return new_c
    x, y, r = new_c
    ox, oy, orr = old_c
    return (
        int(ox * (1 - ALPHA) + x * ALPHA),
        int(oy * (1 - ALPHA) + y * ALPHA),
        int(orr * (1 - ALPHA) + r * ALPHA),
    )


def apply_processing(frame):
    global prev_circle, frame_id, misses

    frame_id += 1
    src = frame
    output = src.copy()

    # decide if we run Hough this frame
    run_detect = (prev_circle is None) or (frame_id % DETECT_EVERY == 0)

    if run_detect:
        h, w = src.shape[:2]
        small = cv.resize(src, (int(w * SCALE), int(h * SCALE)), interpolation=cv.INTER_LINEAR)

        gray = cv.cvtColor(small, cv.COLOR_BGR2GRAY)
        gray = cv.GaussianBlur(gray, (7, 7), 0)

        rows = gray.shape[0]
        min_radius = int(rows * 0.10)
        max_radius = int(rows * 0.38)

        circles = cv.HoughCircles(
            gray,
            cv.HOUGH_GRADIENT,
            dp=1.2,
            minDist=rows // 2,
            param1=160,
            param2=32,
            minRadius=min_radius,
            maxRadius=max_radius
        )

        if circles is not None:
            circles = np.round(circles[0]).astype(int)

            # pick best circle near previous one to reduce jumping
            if prev_circle is not None:
                px, py, pr = prev_circle
                pxs, pys, prs = int(px * SCALE), int(py * SCALE), int(pr * SCALE)

                best = None
                best_score = -1e9
                for (x, y, r) in circles:
                    dist = (x - pxs) * (x - pxs) + (y - pys) * (y - pys)
                    score = (r * 2) - 0.002 * dist  # prefer bigger + closer
                    if score > best_score:
                        best_score = score
                        best = (x, y, r)
                x, y, r = best
            else:
                x, y, r = max(circles, key=lambda c: c[2])

            # scale back to full res
            found = (int(x / SCALE), int(y / SCALE), int(r / SCALE))

            prev_circle = smooth_circle(found, prev_circle)
            misses = 0
        else:
            misses += 1
            if misses > MAX_MISSES:
                prev_circle = None

    # draw latest circle every frame (even between detections)
    if prev_circle is not None:
        x, y, r = prev_circle
        cv.circle(output, (x, y), r, (0, 255, 67), 6)
        cv.circle(output, (x, y), 4, (0, 255, 67), -1)

    return output


def read_and_process_video(video_path):
    cap = cv.VideoCapture(video_path)
    if not cap.isOpened():
        print("Error: Could not open video source:", video_path)
        return

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        processed = apply_processing(frame)
        cv.imshow("Frame Window", processed)

        key = cv.waitKey(1) & 0xFF
        if key == 27 or key == ord('0'):
            break

    cap.release()
    cv.destroyAllWindows()


read_and_process_video("rowing_can.mp4")
