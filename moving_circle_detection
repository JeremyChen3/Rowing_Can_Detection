# Soda Can Bottom Circle Detection
# Pseudocode:
# 1) Read video frames
# 2) Resize + grayscale + blur + edges
# 3) If no previous circle: search whole frame
# 4) Else: search near previous circle
# 5) Pick best circle, smooth it, draw it

import cv2 as cv
import numpy as np

prev_circle = None
misses = 0

ALPHA = 0.60
MAX_MISSES = 5
SCALE = 0.4

# Smoothing video source
def smooth_circle(new_c, old_c):
    if old_c is None:
        return new_c
    x, y, r = new_c
    ox, oy, orr = old_c
    return (
        int(ox * (1 - ALPHA) + x * ALPHA),
        int(oy * (1 - ALPHA) + y * ALPHA),
        int(orr * (1 - ALPHA) + r * ALPHA),
    )

# Edge score
def circle_edge_score(edges, x, y, r, samples=64):
    h, w = edges.shape[:2]
    hits = 0
    for k in range(samples):
        a = 2 * np.pi * k / samples
        px = int(x + r * np.cos(a))
        py = int(y + r * np.sin(a))
        if 0 <= px < w and 0 <= py < h and edges[py, px] > 0:
            hits += 1
    return hits / samples

# Main process applied to frames
def apply_processing(frame):
    global prev_circle, misses

    out = frame.copy()
    H, W = frame.shape[:2]
# Resize
    small = cv.resize(frame, (int(W * SCALE), int(H * SCALE)), interpolation=cv.INTER_LINEAR)

# Preprocess
    gray = cv.cvtColor(small, cv.COLOR_BGR2GRAY)
    gray = cv.GaussianBlur(gray, (7, 7), 0)
    edges = cv.Canny(gray, 70, 160)

    sh, sw = gray.shape[:2]

# Decide where to search
    if prev_circle is None:
        roi_gray, roi_edges = gray, edges
        x1 = y1 = 0
        rows = gray.shape[0]
        minR, maxR = int(rows * 0.06), int(rows * 0.28)
        minDist = rows // 2
        dp = 1.2
    else:
        px, py, pr = prev_circle
        pxs, pys, prs = int(px * SCALE), int(py * SCALE), int(pr * SCALE)

        pad = int(prs * 1.6)
        x1, x2 = max(0, pxs - pad), min(sw, pxs + pad)
        y1, y2 = max(0, pys - pad), min(sh, pys + pad)

        roi_gray = gray[y1:y2, x1:x2]
        roi_edges = edges[y1:y2, x1:x2]

        minR, maxR = max(8, int(prs * 0.90)), int(prs * 1.12)
        minDist = max(10, roi_gray.shape[0] // 3)
        dp = 1.15

# Hough Circle Detection
    circles = cv.HoughCircles(
        roi_gray, cv.HOUGH_GRADIENT,
        dp=dp, minDist=minDist,
        param1=180, param2=30,
        minRadius=minR, maxRadius=maxR
    )

# Find best circle fit
    if circles is not None:
        circles = np.round(circles[0]).astype(int)

        best = None
        best_s = -1
        for x, y, r in circles:
            s = circle_edge_score(roi_edges, x, y, r)
            if s > best_s:
                best_s = s
                best = (x, y, r)

        x, y, r = best
        x += x1
        y += y1

        found = (int(x / SCALE), int(y / SCALE), int(r / SCALE))
        prev_circle = smooth_circle(found, prev_circle)
        misses = 0
    else:
        misses += 1
        if misses > MAX_MISSES:
            prev_circle = None

# Draw overlay
    if prev_circle is not None:
        x, y, r = prev_circle
        cv.circle(out, (x, y), r, (0, 255, 67), 6)
        cv.circle(out, (x, y), 4, (0, 255, 67), -1)

    return out

# Video loop
def read_and_process_video(video_path):
    cap = cv.VideoCapture(video_path)
    if not cap.isOpened():
        print("Error: Could not open video source:", video_path)
        return

    while True:
        ret, frame = cap.read()
        if not ret:
            break
        cv.imshow("Frame Window", apply_processing(frame))
        key = cv.waitKey(1) & 0xFF
        if key == 27 or key == ord('0'):
            break

    cap.release()
    cv.destroyAllWindows()

# Initiate program
read_and_process_video("rowing_can.mp4")
